# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' @title The Fast and Optimal Support Algorithm
#'
#' Description
#' @param X: An n x p design matrix.
#' @param Y: A 1 x p array representing the predictors
#' @param solver_type: The type of iterative solver used internally. Can used
#' sub-gradient descent methods or coordinate descent, both of which
#' can use GAPSAFE screening rules or not.
#' @param use_single_precision: If set to TRUE double-precision floating point values
#' will be cast to single-precision. This will result in less memory use and faster
#' execution, but may result in numerical precision issues.
#'
#' @return A list containing the results of the regression.
#' \item{beta}{The coefficients of the regression results}
#' \item{index}{The number of the grid element where the algorithm stops, in the range 1 - 100 }
#' \item{lambda}{The regularization parameter that was deemed optimal}
#' \item{intercept}{Value of the intercept term.}
#' \item{support}{The estimated support. Enteries will be 0 if the regression coefficient was
#' zero, and 1 if it was non-zero and signifigant.}
#'
#' @description Perform an L1 regularized linear regression using the Fast and Optimal Support
#'  algorithm.
#'
#' @references Néhémy Lim, Johannes Lederer (2016)
#'   \emph{Efficient Feature Selection With Large and High-dimensional Data},
#'      \url{https://arxiv.org/abs/1609.07195}\cr
#'   \emph{Pre-print via ArXiv}\cr
#'   \url{https://arxiv.org}\cr
#'
#' @author Benjamin J Phillips e-mail:bejphil@uw.edu
#'
#' @examples
#' library(HDIM)
#'
#' dataset <- matrix(rexp(200, rate=.1), ncol=20)
#'
#' yinput <- dataset[, 1, drop = FALSE]
#' xinput <- dataset[, names(dataset) != names(yinput)]
#'
#' fos_fit <- HDIM::FOS( as.matrix(xinput), as.matrix(yinput), "cd" )
FOS <- function(X, Y, solver_type, use_single_precision = FALSE) {
    .Call('HDIM_FOS', PACKAGE = 'HDIM', X, Y, solver_type, use_single_precision)
}

#' @title Coordinate Descent
#'
#' Description
#' @param X: An n x p design matrix.
#' @param Y: A 1 x p matrix representing the predictors
#' @param Beta_0: A 1 x n matrix that describes the initial guess for Beta
#' @param Lambda: The regularization hyper-parameter, ie Lambda*|| Beta ||_1
#' @param convergence_criteria: Can be either an positive integer descrbing the number
#' if iterations that the solve should be run for, or a positive float describing
#' the smallest allowable Duality Gap.
#' @param use_screening_rules: Enable or disable GAPSAFE screening rules. Enabling
#' these rules MAY speed up the algorithm.
#' @param use_single_precision: If set to TRUE double-precision floating point values
#' will be cast to single-precision. This will result in less memory use and faster
#' execution, but may result in numerical precision issues.
#'
#' @return A vector containing the coefficients of Beta after the specified convergence
#'    criteria has been meet.
#'
#' @description Use coordinate descent to iteratively solve the LASSO.
#'
#' @details In practice Coordinate Descent is often faster than sub-gradient
#' methods such as ISTA and FISTA.
#'
#' @seealso \code{ISTA} and \code{FISTA}
#'
#' @references Geoff Gordon & Ryan Tibshirani
#'   \emph{Coordinate descent},
#'      \url{https://www.cs.cmu.edu/~ggordon/10725-F12/slides/25-coord-desc.pdf}\cr
#'
#' @author Benjamin J Phillips e-mail:bejphil@uw.edu
#'
#' @examples
#' # Iterative solving
#'
#' library(HDIM)
#'
#' dataset <- matrix(rexp(200, rate=.1), ncol=20)
#'
#' Y <- dataset[, 1, drop = FALSE]
#' X <- dataset
#' Beta_0 <- as.matrix(numeric(ncol(X)))
#'
#' HDIM::CoordinateDescent( X, Y, Beta_0, 50, as.integer(5) )
#'
#' # Duality gap convergence criteria.
#'
#' library(HDIM)
#'
#' dataset <- matrix(rexp(200, rate=.1), ncol=20)
#'
#' Y <- dataset[, 1, drop = FALSE]
#' X <- dataset
#' Beta_0 <- as.matrix(numeric(ncol(X)))
#'
#' HDIM::CoordinateDescent( X, Y, Beta_0, 50, 0.1 )
CoordinateDescent <- function(X, Y, Beta_0, Lambda, convergence_criteria, use_screening_rules = FALSE, use_single_precision = FALSE) {
    .Call('HDIM_CoordinateDescent', PACKAGE = 'HDIM', X, Y, Beta_0, Lambda, convergence_criteria, use_screening_rules, use_single_precision)
}

#' @title Iterative Shrinkage Thresholding Algorithm ( ISTA )
#'
#' Description
#' @param X: An n x p design matrix.
#' @param Y: A 1 x p matrix representing the predictors
#' @param Beta_0: A 1 x n matrix that describes the initial guess for Beta
#' @param Lambda: The regularization hyper-parameter, ie Lambda*|| Beta ||_1
#' @param convergence_criteria: Can be either an positive integer descrbing the number
#' if iterations that the solve should be run for, or a positive float describing
#' the smallest allowable Duality Gap.
#' @param L_0: Learning rate used by the backtracking line search.
#' @param use_screening_rules: Enable or disable GAPSAFE screening rules. Enabling
#' these rules MAY speed up the algorithm.
#' @param use_single_precision: If set to TRUE double-precision floating point values
#' will be cast to single-precision. This will result in less memory use and faster
#' execution, but may result in numerical precision issues.
#'
#' @return A vector containing the coefficients of Beta after the specified convergence
#'    criteria has been meet.
#'
#' @description Use ISTA to iteritively solve the LASSO.
#'
#' @details In practice Coordinate Descent is often faster than sub-gradient
#' methods such as this method and FISTA.
#'
#' @seealso \code{CoordinateDescent} and \code{FISTA}
#'
#' @author Benjamin J Phillips e-mail:bejphil@uw.edu
#'
#' @examples
#' # Iterative solving
#'
#' library(HDIM)
#'
#' dataset <- matrix(rexp(200, rate=.1), ncol=20)
#'
#' Y <- dataset[, 1, drop = FALSE]
#' X <- dataset
#' Beta_0 <- as.matrix(numeric(ncol(X)))
#'
#' HDIM::ISTA( X, Y, Beta_0, 50, as.integer(5) )
#'
#' # Duality gap convergence criteria.
#'
#' library(HDIM)
#'
#' dataset <- matrix(rexp(200, rate=.1), ncol=20)
#'
#' Y <- dataset[, 1, drop = FALSE]
#' X <- dataset
#' Beta_0 <- as.matrix(numeric(ncol(X)))
#'
#' HDIM::ISTA( X, Y, Beta_0, 50, 0.1 )
ISTA <- function(X, Y, Beta_0, Lambda, convergence_criteria, L_0 = 0.1, use_screening_rules = FALSE, use_single_precision = FALSE) {
    .Call('HDIM_ISTA', PACKAGE = 'HDIM', X, Y, Beta_0, Lambda, convergence_criteria, L_0, use_screening_rules, use_single_precision)
}

#' @title Fast Iterative Shrinkage Thresholding Algorithm ( FISTA )
#'
#' Description
#' @param X: An n x p design matrix.
#' @param Y: A 1 x p matrix representing the predictors
#' @param Beta_0: A 1 x n matrix that describes the initial guess for Beta
#' @param Lambda: The regularization hyper-parameter, ie Lambda*|| Beta ||_1
#' @param convergence_criteria: Can be either an positive integer descrbing the number
#' if iterations that the solve should be run for, or a positive float describing
#' the smallest allowable Duality Gap.
#' @param L_0: Learning rate used by the backtracking line search.
#' @param use_screening_rules: Enable or disable GAPSAFE screening rules. Enabling
#' these rules MAY speed up the algorithm.
#' @param use_single_precision: If set to TRUE double-precision floating point values
#' will be cast to single-precision. This will result in less memory use and faster
#' execution, but may result in numerical precision issues.
#'
#' @return A vector containing the coefficients of Beta after the specified convergence
#'    criteria has been meet.
#'
#' @description Use FISTA to iteritively solve the LASSO.
#'
#' @details In practice Coordinate Descent is often faster than sub-gradient
#' methods such as this method and ISTA. This method will be faster than ISTA
#' in almost all cases.
#'
#' @seealso \code{CoordinateDescent} and \code{ISTA}
#'
#' @references Amir Beck & Marc Teboulle (2009)
#'   \emph{AFastIterativeShrinkage-Thresholding Algorithm for Linear Inverse Problems},
#'      \url{https://people.rennes.inria.fr/Cedric.Herzet/Cedric.Herzet/Sparse_Seminar/Entrees/2012/11/12_A_Fast_Iterative_Shrinkage-Thresholding_Algorithmfor_Linear_Inverse_Problems_(A._Beck,_M._Teboulle)_files/Breck_2009.pdf}\cr
#'   \emph{SIAM J. IMAGING SCIENCES}\cr
#'   \url{https://www.siam.org/journals/siims.php}\cr
#'
#' @author Benjamin J Phillips e-mail:bejphil@uw.edu
#'
#' @examples
#' # Iterative solving
#'
#' library(HDIM)
#'
#' dataset <- matrix(rexp(200, rate=.1), ncol=20)
#'
#' Y <- dataset[, 1, drop = FALSE]
#' X <- dataset
#' Beta_0 <- as.matrix(numeric(ncol(X)))
#'
#' HDIM::FISTA( X, Y, Beta_0, 50, as.integer(5) )
#'
#' # Duality gap convergence criteria.
#'
#' library(HDIM)
#'
#' dataset <- matrix(rexp(200, rate=.1), ncol=20)
#'
#' Y <- dataset[, 1, drop = FALSE]
#' X <- dataset
#' Beta_0 <- as.matrix(numeric(ncol(X)))
#'
#' HDIM::FISTA( X, Y, Beta_0, 50, 0.1 )
FISTA <- function(X, Y, Beta_0, Lambda, convergence_criteria, L_0 = 0.1, use_screening_rules = FALSE, use_single_precision = FALSE) {
    .Call('HDIM_FISTA', PACKAGE = 'HDIM', X, Y, Beta_0, Lambda, convergence_criteria, L_0, use_screening_rules, use_single_precision)
}

