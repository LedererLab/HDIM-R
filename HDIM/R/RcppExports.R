# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' @title The Fast and Optimal Support Algorithm
#'
#' Description
#' @param X: An n x p design matrix.
#' @param Y: A 1 x p array representing the predictors
#' @param solver_type: The type of iterative solver used internally. Can used
#' sub-gradient descent methods or coordinate descent, both of which
#' can use GAPSAFE screening rules or not.
#' @param use_single_precision: If set to TRUE double-precision floating point values
#' will be cast to single-precision. This will result in less memory usable and faster
#' execution, but may result in numerical precision issues.
#'
#' @return A list containing the results of the regression.
#' \item{beta}{The coefficients of the regression results}
#' \item{index}{The number of the grid element where the algorithm stops, in the range 1 - 100 }
#' \item{lambda}{The regularization parameter that was deemed optimal}
#' \item{intercept}{Value of the intercept term.}
#' \item{support}{The estimated support. Enteries will be 0 if the regression coefficient was
#' zero, and 1 if it was non-zero and signifigant.}
#'
#' @description Perform an L1 regularized linear regression using the Fast and Optimal Support
#'  algorithm.
#'
#' @references Néhémy Lim, Johannes Lederer (2016)
#'   \emph{Efficient Feature Selection With Large and High-dimensional Data},
#'      \url{https://arxiv.org/abs/1609.07195}\cr
#'   \emph{Pre-print via ArXiv}\cr
#'   \url{https://arxiv.org}\cr
#'
#' @author Benjamin J Phillips e-mail:bejphil@uw.edu
#'
#' @examples
#' library(HDIM)
#'
#' dataset <- matrix(rexp(200, rate=.1), ncol=20)
#'
#' yinput <- dataset[, 1, drop = FALSE]
#' xinput <- dataset[, names(dataset) != names(yinput)]
#'
#' fos_fit <- HDIM::FOS( as.matrix(xinput), as.matrix(yinput), "cd" )
FOS <- function(X, Y, solver_type, use_single_precision = FALSE) {
    .Call('HDIM_FOS', PACKAGE = 'HDIM', X, Y, solver_type, use_single_precision)
}

CD <- function(X, Y, Beta_0, lambda, num_iterations) {
    .Call('HDIM_CD', PACKAGE = 'HDIM', X, Y, Beta_0, lambda, num_iterations)
}

CDSR <- function(X, Y, Beta_0, lambda, num_iterations) {
    .Call('HDIM_CDSR', PACKAGE = 'HDIM', X, Y, Beta_0, lambda, num_iterations)
}

CDDG <- function(X, Y, Beta_0, lambda, duality_gap_target) {
    .Call('HDIM_CDDG', PACKAGE = 'HDIM', X, Y, Beta_0, lambda, duality_gap_target)
}

CDSRDG <- function(X, Y, Beta_0, lambda, duality_gap_target) {
    .Call('HDIM_CDSRDG', PACKAGE = 'HDIM', X, Y, Beta_0, lambda, duality_gap_target)
}

ISTA <- function(X, Y, Beta_0, lambda, num_iterations, L_0 = 0.1) {
    .Call('HDIM_ISTA', PACKAGE = 'HDIM', X, Y, Beta_0, lambda, num_iterations, L_0)
}

ISTASR <- function(X, Y, Beta_0, lambda, num_iterations, L_0 = 0.1) {
    .Call('HDIM_ISTASR', PACKAGE = 'HDIM', X, Y, Beta_0, lambda, num_iterations, L_0)
}

ISTA_DG <- function(X, Y, Beta_0, lambda, duality_gap_target, L_0 = 0.1) {
    .Call('HDIM_ISTA_DG', PACKAGE = 'HDIM', X, Y, Beta_0, lambda, duality_gap_target, L_0)
}

ISTASR_DG <- function(X, Y, Beta_0, lambda, duality_gap_target, L_0 = 0.1) {
    .Call('HDIM_ISTASR_DG', PACKAGE = 'HDIM', X, Y, Beta_0, lambda, duality_gap_target, L_0)
}

FISTA <- function(X, Y, Beta_0, lambda, num_iterations, L_0 = 0.1) {
    .Call('HDIM_FISTA', PACKAGE = 'HDIM', X, Y, Beta_0, lambda, num_iterations, L_0)
}

FISTASR <- function(X, Y, Beta_0, lambda, num_iterations, L_0 = 0.1) {
    .Call('HDIM_FISTASR', PACKAGE = 'HDIM', X, Y, Beta_0, lambda, num_iterations, L_0)
}

FISTA_DG <- function(X, Y, Beta_0, lambda, duality_gap_target, L_0 = 0.1) {
    .Call('HDIM_FISTA_DG', PACKAGE = 'HDIM', X, Y, Beta_0, lambda, duality_gap_target, L_0)
}

FISTASR_DG <- function(X, Y, Beta_0, lambda, duality_gap_target, L_0 = 0.1) {
    .Call('HDIM_FISTASR_DG', PACKAGE = 'HDIM', X, Y, Beta_0, lambda, duality_gap_target, L_0)
}

